var CoreModule = {};
CoreModule['assert'] = 'assert';
CoreModule['buffer'] = 'buffer';
CoreModule['child_process'] = 'child_process';
CoreModule['crypto'] = 'crypto';
CoreModule['dgram'] = 'dgram';
CoreModule['events'] = 'events';
CoreModule['fs'] = 'fs';
CoreModule['http'] = 'http';
CoreModule['net'] = 'net';
CoreModule['os'] = 'os';
CoreModule['path'] = 'path';
CoreModule['stream'] = 'stream';
CoreModule['string_decoder'] = 'string_decoder';
CoreModule['url'] = 'url';
CoreModule['util'] = 'util';
CoreModule['zlib'] = 'zlib';
var BundleModuleCode = [];
var BundleObjectCode = [];
var BundleModules = [];
var Fs = require('fs');
PATH = [
    process.cwd(),
    '.',
    ''
];
// function _isdir(path)
function _isdir(path) {
    var stats = Fs.lstatSync(path);
    return stats.isDirectory();
}
// function _search(index,file)
function _search(index, file) {
    if (PATH.length == index)
        return file;
    var path = PATH[index];
    if (Fs.existsSync(path + '/' + file + '.js'))
        return path + '/' + file + '.js';
    else if (Fs.existsSync(path + '/' + file) && !_isdir(path + '/' + file))
        return path + '/' + file;
    else
        return _search(index + 1, file);
}
global.Require = function (modupath) {
    var file, filepath;
    if (CoreModule[modupath] != undefined)
        modupath = CoreModule[modupath];
    if (modupath == '')
        return undefined;
    if (BundleModules[modupath])
        return BundleModules[modupath];
    var exports = {};
    var module = { exports: exports };
    if (BundleModuleCode[modupath])
        BundleModuleCode[modupath](module, exports);
    else if (BundleObjectCode[modupath])
        BundleObjectCode[modupath](module, exports);
    else {
        try {
            file = _search(0, modupath);
            module = require(file);
        } catch (e) {
            var more = '';
            if ((e.name === 'SyntaxError' || e.name === 'TypeError') && file) {
                var src = Fs.readFileSync(file, 'utf8');
                var Esprima = Require('parser/esprima');
                try {
                    var ast = Esprima.parse(src, {
                        tolerant: true,
                        loc: true
                    });
                    if (ast.errors && ast.errors.length > 0)
                        more = ', ' + ast.errors[0];
                } catch (e) {
                    if (e.lineNumber)
                        more = ', in line ' + e.lineNumber;
                }
            }
            console.log('Require import of ' + modupath + ' (' + file + ') failed: ' + e + more);
            throw e;
        }
    }
    BundleModules[modupath] = module.exports || module;
    return module.exports || module;
};
global.FilesEmbedded = {};
global.FileEmbedd = function (path, format) {
};
global.FileEmbedded = function (path, format) {
    return FilesEmbedded[path](format);
};
global.TARGET = 'any';
BundleObjectCode['os/assert'] = function (module, exports) {
    'use strict';
    // function compare(a,b)
function compare(a, b) {
        if (a === b) {
            return 0;
        }
        var x = a.length;
        var y = b.length;
        for (var i = 0, len = Math.min(x, y); i < len; ++i) {
            if (a[i] !== b[i]) {
                x = a[i];
                y = b[i];
                break;
            }
        }
        if (x < y) {
            return -1;
        }
        if (y < x) {
            return 1;
        }
        return 0;
    }
    // function isBuffer(b)
function isBuffer(b) {
        if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
            return global.Buffer.isBuffer(b);
        }
        return !!(b != null && b._isBuffer);
    }
    var util = Require('util');
    var hasOwn = Object.prototype.hasOwnProperty;
    var pSlice = Array.prototype.slice;
    var functionsHaveNames = function () {
        return function foo() {
        }.name === 'foo';
    }();
    // function pToString(obj)
function pToString(obj) {
        return Object.prototype.toString.call(obj);
    }
    // function isView(arrbuf)
function isView(arrbuf) {
        if (isBuffer(arrbuf)) {
            return false;
        }
        if (typeof global.ArrayBuffer !== 'function') {
            return false;
        }
        if (typeof ArrayBuffer.isView === 'function') {
            return ArrayBuffer.isView(arrbuf);
        }
        if (!arrbuf) {
            return false;
        }
        if (arrbuf instanceof DataView) {
            return true;
        }
        if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
            return true;
        }
        return false;
    }
    var assert = module.exports = ok;
    var regex = /\s*function\s+([^\(\s]*)\s*/;
    // function getName(func)
function getName(func) {
        if (!util.isFunction(func)) {
            return;
        }
        if (functionsHaveNames) {
            return func.name;
        }
        var str = func.toString();
        var match = str.match(regex);
        return match && match[1];
    }
    assert.AssertionError = function AssertionError(options) {
        this.name = 'AssertionError';
        this.actual = options.actual;
        this.expected = options.expected;
        this.operator = options.operator;
        if (options.message) {
            this.message = options.message;
            this.generatedMessage = false;
        } else {
            this.message = getMessage(this);
            this.generatedMessage = true;
        }
        var stackStartFunction = options.stackStartFunction || fail;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, stackStartFunction);
        } else {
            var err = new Error();
            if (err.stack) {
                var out = err.stack;
                var fn_name = getName(stackStartFunction);
                var idx = out.indexOf('\n' + fn_name);
                if (idx >= 0) {
                    var next_line = out.indexOf('\n', idx + 1);
                    out = out.substring(next_line + 1);
                }
                this.stack = out;
            }
        }
    };
    util.inherits(assert.AssertionError, Error);
    // function truncate(s,n)
function truncate(s, n) {
        if (typeof s === 'string') {
            return s.length < n ? s : s.slice(0, n);
        } else {
            return s;
        }
    }
    // function inspect(something)
function inspect(something) {
        if (functionsHaveNames || !util.isFunction(something)) {
            return util.inspect(something);
        }
        var rawname = getName(something);
        var name = rawname ? ': ' + rawname : '';
        return '[Function' + name + ']';
    }
    // function getMessage(self)
function getMessage(self) {
        return truncate(inspect(self.actual), 128) + ' ' + self.operator + ' ' + truncate(inspect(self.expected), 128);
    }
    // function fail(actual,expected,message,operator,stackStartFunction)
function fail(actual, expected, message, operator, stackStartFunction) {
        throw new assert.AssertionError({
            message: message,
            actual: actual,
            expected: expected,
            operator: operator,
            stackStartFunction: stackStartFunction
        });
    }
    assert.fail = fail;
    // function ok(value,message)
function ok(value, message) {
        if (!value)
            fail(value, true, message, '==', assert.ok);
    }
    assert.ok = ok;
    assert.equal = function equal(actual, expected, message) {
        if (actual != expected)
            fail(actual, expected, message, '==', assert.equal);
    };
    assert.notEqual = function notEqual(actual, expected, message) {
        if (actual == expected) {
            fail(actual, expected, message, '!=', assert.notEqual);
        }
    };
    assert.deepEqual = function deepEqual(actual, expected, message) {
        if (!_deepEqual(actual, expected, false)) {
            fail(actual, expected, message, 'deepEqual', assert.deepEqual);
        }
    };
    assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
        if (!_deepEqual(actual, expected, true)) {
            fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
        }
    };
    // function _deepEqual(actual,expected,strict,memos)
function _deepEqual(actual, expected, strict, memos) {
        if (actual === expected) {
            return true;
        } else if (isBuffer(actual) && isBuffer(expected)) {
            return compare(actual, expected) === 0;
        } else if (util.isDate(actual) && util.isDate(expected)) {
            return actual.getTime() === expected.getTime();
        } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
            return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
        } else if ((actual === null || typeof actual !== 'object') && (expected === null || typeof expected !== 'object')) {
            return strict ? actual === expected : actual == expected;
        } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
            return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0;
        } else if (isBuffer(actual) !== isBuffer(expected)) {
            return false;
        } else {
            memos = memos || {
                actual: [],
                expected: []
            };
            var actualIndex = memos.actual.indexOf(actual);
            if (actualIndex !== -1) {
                if (actualIndex === memos.expected.indexOf(expected)) {
                    return true;
                }
            }
            memos.actual.push(actual);
            memos.expected.push(expected);
            return objEquiv(actual, expected, strict, memos);
        }
    }
    // function isArguments(object)
function isArguments(object) {
        return Object.prototype.toString.call(object) == '[object Arguments]';
    }
    // function objEquiv(a,b,strict,actualVisitedObjects)
function objEquiv(a, b, strict, actualVisitedObjects) {
        if (a === null || a === undefined || b === null || b === undefined)
            return false;
        if (util.isPrimitive(a) || util.isPrimitive(b))
            return a === b;
        if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
            return false;
        var aIsArgs = isArguments(a);
        var bIsArgs = isArguments(b);
        if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
            return false;
        if (aIsArgs) {
            a = pSlice.call(a);
            b = pSlice.call(b);
            return _deepEqual(a, b, strict);
        }
        var ka = objectKeys(a);
        var kb = objectKeys(b);
        var key, i;
        if (ka.length !== kb.length)
            return false;
        ka.sort();
        kb.sort();
        for (i = ka.length - 1; i >= 0; i--) {
            if (ka[i] !== kb[i])
                return false;
        }
        for (i = ka.length - 1; i >= 0; i--) {
            key = ka[i];
            if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
                return false;
        }
        return true;
    }
    assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
        if (_deepEqual(actual, expected, false)) {
            fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
        }
    };
    assert.notDeepStrictEqual = notDeepStrictEqual;
    // function notDeepStrictEqual(actual,expected,message)
function notDeepStrictEqual(actual, expected, message) {
        if (_deepEqual(actual, expected, true)) {
            fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
        }
    }
    assert.strictEqual = function strictEqual(actual, expected, message) {
        if (actual !== expected) {
            fail(actual, expected, message, '===', assert.strictEqual);
        }
    };
    assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
        if (actual === expected) {
            fail(actual, expected, message, '!==', assert.notStrictEqual);
        }
    };
    // function expectedException(actual,expected)
function expectedException(actual, expected) {
        if (!actual || !expected) {
            return false;
        }
        if (Object.prototype.toString.call(expected) == '[object RegExp]') {
            return expected.test(actual);
        }
        try {
            if (actual instanceof expected) {
                return true;
            }
        } catch (e) {
        }
        if (Error.isPrototypeOf(expected)) {
            return false;
        }
        return expected.call({}, actual) === true;
    }
    // function _tryBlock(block)
function _tryBlock(block) {
        var error;
        try {
            block();
        } catch (e) {
            error = e;
        }
        return error;
    }
    // function _throws(shouldThrow,block,expected,message)
function _throws(shouldThrow, block, expected, message) {
        var actual;
        if (typeof block !== 'function') {
            throw new TypeError('"block" argument must be a function');
        }
        if (typeof expected === 'string') {
            message = expected;
            expected = null;
        }
        actual = _tryBlock(block);
        message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');
        if (shouldThrow && !actual) {
            fail(actual, expected, 'Missing expected exception' + message);
        }
        var userProvidedMessage = typeof message === 'string';
        var isUnwantedException = !shouldThrow && util.isError(actual);
        var isUnexpectedException = !shouldThrow && actual && !expected;
        if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
            fail(actual, expected, 'Got unwanted exception' + message);
        }
        if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
            throw actual;
        }
    }
    assert.throws = function (block, error, message) {
        _throws(true, block, error, message);
    };
    assert.doesNotThrow = function (block, error, message) {
        _throws(false, block, error, message);
    };
    assert.ifError = function (err) {
        if (err)
            throw err;
    };
    var objectKeys = Object.keys || function (obj) {
        var keys = [];
        for (var key in obj) {
            if (hasOwn.call(obj, key))
                keys.push(key);
        }
        return keys;
    };
};
BundleObjectCode['os/buffer'] = function (module, exports) {
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
    // function init()
function init() {
        var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        for (var i = 0, len = code.length; i < len; ++i) {
            lookup[i] = code[i];
            revLookup[code.charCodeAt(i)] = i;
        }
        revLookup['-'.charCodeAt(0)] = 62;
        revLookup['_'.charCodeAt(0)] = 63;
    }
    init();
    // function toByteArray(b64)
function toByteArray(b64) {
        var i, j, l, tmp, placeHolders, arr;
        var len = b64.length;
        if (len % 4 > 0) {
            throw new Error('Invalid string. Length must be a multiple of 4');
        }
        placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
        arr = new Arr(len * 3 / 4 - placeHolders);
        l = placeHolders > 0 ? len - 4 : len;
        var L = 0;
        for (i = 0, j = 0; i < l; i += 4, j += 3) {
            tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
            arr[L++] = tmp >> 16 & 255;
            arr[L++] = tmp >> 8 & 255;
            arr[L++] = tmp & 255;
        }
        if (placeHolders === 2) {
            tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
            arr[L++] = tmp & 255;
        } else if (placeHolders === 1) {
            tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
            arr[L++] = tmp >> 8 & 255;
            arr[L++] = tmp & 255;
        }
        return arr;
    }
    // function tripletToBase64(num)
function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    // function encodeChunk(uint8,start,end)
function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i = start; i < end; i += 3) {
            tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
            output.push(tripletToBase64(tmp));
        }
        return output.join('');
    }
    // function fromByteArray(uint8)
function fromByteArray(uint8) {
        var tmp;
        var len = uint8.length;
        var extraBytes = len % 3;
        var output = '';
        var parts = [];
        var maxChunkLength = 16383;
        for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
            parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
        }
        if (extraBytes === 1) {
            tmp = uint8[len - 1];
            output += lookup[tmp >> 2];
            output += lookup[tmp << 4 & 63];
            output += '==';
        } else if (extraBytes === 2) {
            tmp = (uint8[len - 2] << 8) + uint8[len - 1];
            output += lookup[tmp >> 10];
            output += lookup[tmp >> 4 & 63];
            output += lookup[tmp << 2 & 63];
            output += '=';
        }
        parts.push(output);
        return parts.join('');
    }
    var assert;
    exports.Buffer = Buffer;
    exports.SlowBuffer = Buffer;
    Buffer.poolSize = 8192;
    exports.INSPECT_MAX_BYTES = 50;
    // function stringtrim(str)
function stringtrim(str) {
        if (str.trim)
            return str.trim();
        return str.replace(/^\s+|\s+$/g, '');
    }
    // function Buffer(subject,encoding,offset)
function Buffer(subject, encoding, offset) {
        if (!assert)
            assert = {
                ok: function (cond, msg) {
                    if (cond != true) {
                        console.log('** Assertion failed: ' + msg + ' **');
                        throw Error(msg);
                    }
                }
            };
        if (!(this instanceof Buffer)) {
            return new Buffer(subject, encoding, offset);
        }
        this.parent = this;
        this.offset = 0;
        if (encoding == 'base64' && typeof subject == 'string') {
            subject = stringtrim(subject);
            while (subject.length % 4 != 0) {
                subject = subject + '=';
            }
        }
        var type;
        if (typeof offset === 'number') {
            this.length = coerce(encoding);
            for (var i = 0; i < this.length; i++) {
                this[i] = subject.get(i + offset);
            }
        } else {
            switch (type = typeof subject) {
            case 'number':
                this.length = coerce(subject);
                break;
            case 'string':
                this.length = Buffer.byteLength(subject, encoding);
                break;
            case 'object':
                this.length = coerce(subject.length);
                break;
            default:
                throw new TypeError('First argument needs to be a number, ' + 'array or string.');
            }
            if (isArrayIsh(subject)) {
                for (var i = 0; i < this.length; i++) {
                    if (subject instanceof Buffer) {
                        this[i] = subject.readUInt8(i);
                    } else {
                        this[i] = (subject[i] % 256 + 256) % 256;
                    }
                }
            } else if (type == 'string') {
                this.length = this.write(subject, 0, encoding);
            } else if (type === 'number') {
                for (var i = 0; i < this.length; i++) {
                    this[i] = 0;
                }
            }
        }
    }
    Buffer.prototype.get = function get(i) {
        if (i < 0 || i >= this.length)
            throw new Error('oob');
        return this[i];
    };
    Buffer.prototype.set = function set(i, v) {
        if (i < 0 || i >= this.length)
            throw new Error('oob');
        return this[i] = v;
    };
    Buffer.byteLength = function (str, encoding) {
        switch (encoding || 'utf8') {
        case 'hex':
            return str.length / 2;
        case 'utf8':
        case 'utf-8':
            return utf8ToBytes(str).length;
        case 'ascii':
        case 'binary':
            return str.length;
        case 'base64':
            return base64ToBytes(str).length;
        default:
            throw new Error('Unknown encoding');
        }
    };
    Buffer.prototype.utf8Write = function (string, offset, length) {
        var bytes, pos;
        return Buffer._charsWritten = blitBuffer(utf8ToBytes(string), this, offset, length);
    };
    Buffer.prototype.asciiWrite = function (string, offset, length) {
        var bytes, pos;
        return Buffer._charsWritten = blitBuffer(asciiToBytes(string), this, offset, length);
    };
    Buffer.prototype.binaryWrite = Buffer.prototype.asciiWrite;
    Buffer.prototype.base64Write = function (string, offset, length) {
        var bytes, pos;
        return Buffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
    };
    Buffer.prototype.base64Slice = function (start, end) {
        var bytes = Array.prototype.slice.apply(this, arguments);
        return fromByteArray(bytes);
    };
    Buffer.prototype.utf8Slice = function () {
        var bytes = Array.prototype.slice.apply(this, arguments);
        var res = '';
        var tmp = '';
        var i = 0;
        while (i < bytes.length) {
            if (bytes[i] <= 127) {
                res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
                tmp = '';
            } else
                tmp += '%' + bytes[i].toString(16);
            i++;
        }
        return res + decodeUtf8Char(tmp);
    };
    Buffer.prototype.asciiSlice = function () {
        var bytes = Array.prototype.slice.apply(this, arguments);
        var ret = '';
        for (var i = 0; i < bytes.length; i++)
            ret += String.fromCharCode(bytes[i]);
        return ret;
    };
    Buffer.prototype.binarySlice = Buffer.prototype.asciiSlice;
    Buffer.prototype.inspect = function () {
        var out = [], len = this.length;
        for (var i = 0; i < len; i++) {
            out[i] = toHex(this[i]);
            if (i == exports.INSPECT_MAX_BYTES) {
                out[i + 1] = '...';
                break;
            }
        }
        return '<Buffer ' + out.join(' ') + '>';
    };
    Buffer.prototype.hexSlice = function (start, end) {
        var len = this.length;
        if (!start || start < 0)
            start = 0;
        if (!end || end < 0 || end > len)
            end = len;
        var out = '';
        for (var i = start; i < end; i++) {
            out += toHex(this[i]);
        }
        return out;
    };
    Buffer.prototype.toString = function (encoding, start, end) {
        encoding = String(encoding || 'utf8').toLowerCase();
        start = +start || 0;
        if (typeof end == 'undefined')
            end = this.length;
        if (+end == start) {
            return '';
        }
        switch (encoding) {
        case 'hex':
            return this.hexSlice(start, end);
        case 'utf8':
        case 'utf-8':
            return this.utf8Slice(start, end);
        case 'ascii':
            return this.asciiSlice(start, end);
        case 'binary':
            return this.binarySlice(start, end);
        case 'base64':
            return this.base64Slice(start, end);
        case 'ucs2':
        case 'ucs-2':
            return this.ucs2Slice(start, end);
        default:
            throw new Error('Unknown encoding');
        }
    };
    Buffer.prototype.hexWrite = function (string, offset, length) {
        offset = +offset || 0;
        var remaining = this.length - offset;
        if (!length) {
            length = remaining;
        } else {
            length = +length;
            if (length > remaining) {
                length = remaining;
            }
        }
        var strLen = string.length;
        if (strLen % 2) {
            throw new Error('Invalid hex string');
        }
        if (length > strLen / 2) {
            length = strLen / 2;
        }
        for (var i = 0; i < length; i++) {
            var b = parseInt(string.substr(i * 2, 2), 16);
            if (isNaN(b))
                throw new Error('Invalid hex string');
            this[offset + i] = b;
        }
        Buffer._charsWritten = i * 2;
        return i;
    };
    Buffer.prototype.write = function (string, offset, length, encoding) {
        if (isFinite(offset)) {
            if (!isFinite(length)) {
                encoding = length;
                length = undefined;
            }
        } else {
            var swap = encoding;
            encoding = offset;
            offset = length;
            length = swap;
        }
        offset = +offset || 0;
        var remaining = this.length - offset;
        if (!length) {
            length = remaining;
        } else {
            length = +length;
            if (length > remaining) {
                length = remaining;
            }
        }
        encoding = String(encoding || 'utf8').toLowerCase();
        switch (encoding) {
        case 'hex':
            return this.hexWrite(string, offset, length);
        case 'utf8':
        case 'utf-8':
            return this.utf8Write(string, offset, length);
        case 'ascii':
            return this.asciiWrite(string, offset, length);
        case 'binary':
            return this.binaryWrite(string, offset, length);
        case 'base64':
            return this.base64Write(string, offset, length);
        case 'ucs2':
        case 'ucs-2':
            return this.ucs2Write(string, offset, length);
        default:
            throw new Error('Unknown encoding');
        }
    };
    // function clamp(index,len,defaultValue)
function clamp(index, len, defaultValue) {
        if (typeof index !== 'number')
            return defaultValue;
        index = ~~index;
        if (index >= len)
            return len;
        if (index >= 0)
            return index;
        index += len;
        if (index >= 0)
            return index;
        return 0;
    }
    Buffer.prototype.slice = function (start, end) {
        var len = this.length;
        start = clamp(start, len, 0);
        end = clamp(end, len, len);
        return new Buffer(this, end - start, +start);
    };
    Buffer.prototype.copy = function (target, target_start, start, end) {
        var source = this;
        start || (start = 0);
        if (end === undefined || isNaN(end)) {
            end = this.length;
        }
        target_start || (target_start = 0);
        if (end < start)
            throw new Error('sourceEnd < sourceStart');
        if (end === start)
            return 0;
        if (target.length == 0 || source.length == 0)
            return 0;
        if (target_start < 0 || target_start >= target.length) {
            throw new Error('targetStart out of bounds');
        }
        if (start < 0 || start >= source.length) {
            throw new Error('sourceStart out of bounds');
        }
        if (end < 0 || end > source.length) {
            throw new Error('sourceEnd out of bounds');
        }
        if (end > this.length) {
            end = this.length;
        }
        if (target.length - target_start < end - start) {
            end = target.length - target_start + start;
        }
        var temp = [];
        for (var i = start; i < end; i++) {
            assert.ok(typeof this[i] !== 'undefined', 'copying undefined buffer bytes!');
            temp.push(this[i]);
        }
        for (var i = target_start; i < target_start + temp.length; i++) {
            target[i] = temp[i - target_start];
        }
    };
    Buffer.prototype.fill = function fill(value, start, end) {
        value || (value = 0);
        start || (start = 0);
        end || (end = this.length);
        if (typeof value === 'string') {
            value = value.charCodeAt(0);
        }
        if (!(typeof value === 'number') || isNaN(value)) {
            throw new Error('value is not a number');
        }
        if (end < start)
            throw new Error('end < start');
        if (end === start)
            return 0;
        if (this.length == 0)
            return 0;
        if (start < 0 || start >= this.length) {
            throw new Error('start out of bounds');
        }
        if (end < 0 || end > this.length) {
            throw new Error('end out of bounds');
        }
        for (var i = start; i < end; i++) {
            this[i] = value;
        }
    };
    Buffer.isBuffer = function isBuffer(b) {
        return b instanceof Buffer;
    };
    Buffer.concat = function (list, totalLength) {
        if (!isArray(list)) {
            throw new Error('Usage: Buffer.concat(list, [totalLength])\n       list should be an Array.');
        }
        if (list.length === 0) {
            return new Buffer(0);
        } else if (list.length === 1) {
            return list[0];
        }
        if (typeof totalLength !== 'number') {
            totalLength = 0;
            for (var i = 0; i < list.length; i++) {
                var buf = list[i];
                totalLength += buf.length;
            }
        }
        var buffer = new Buffer(totalLength);
        var pos = 0;
        for (var i = 0; i < list.length; i++) {
            var buf = list[i];
            buf.copy(buffer, pos);
            pos += buf.length;
        }
        return buffer;
    };
    Buffer.isEncoding = function (encoding) {
        switch ((encoding + '').toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
        case 'raw':
            return true;
        default:
            return false;
        }
    };
    // function coerce(length)
function coerce(length) {
        length = ~~Math.ceil(+length);
        return length < 0 ? 0 : length;
    }
    // function isArray(subject)
function isArray(subject) {
        return (Array.isArray || function (subject) {
            return {}.toString.apply(subject) == '[object Array]';
        })(subject);
    }
    // function isArrayIsh(subject)
function isArrayIsh(subject) {
        return isArray(subject) || Buffer.isBuffer(subject) || subject && typeof subject === 'object' && typeof subject.length === 'number';
    }
    // function toHex(n)
function toHex(n) {
        if (n < 16)
            return '0' + n.toString(16);
        return n.toString(16);
    }
    // function utf8ToBytes(str)
function utf8ToBytes(str) {
        var byteArray = [];
        for (var i = 0; i < str.length; i++)
            if (str.charCodeAt(i) <= 127)
                byteArray.push(str.charCodeAt(i));
            else {
                var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
                for (var j = 0; j < h.length; j++)
                    byteArray.push(parseInt(h[j], 16));
            }
        return byteArray;
    }
    // function asciiToBytes(str)
function asciiToBytes(str) {
        var byteArray = [];
        for (var i = 0; i < str.length; i++)
            byteArray.push(str.charCodeAt(i) & 255);
        return byteArray;
    }
    // function base64ToBytes(str)
function base64ToBytes(str) {
        return toByteArray(str);
    }
    // function blitBuffer(src,dst,offset,length)
function blitBuffer(src, dst, offset, length) {
        var pos, i = 0;
        while (i < length) {
            if (i + offset >= dst.length || i >= src.length)
                break;
            dst[i + offset] = src[i];
            i++;
        }
        return i;
    }
    // function decodeUtf8Char(str)
function decodeUtf8Char(str) {
        try {
            return decodeURIComponent(str);
        } catch (err) {
            return String.fromCharCode(65533);
        }
    }
    Buffer.prototype.readUInt8 = function (offset, noAssert) {
        var buffer = this;
        if (!noAssert) {
            assert.ok(offset !== undefined && offset !== null, 'missing offset');
            assert.ok(offset < buffer.length, 'Trying to read beyond buffer length');
        }
        if (offset >= buffer.length)
            return;
        return buffer[offset];
    };
    // function readUInt16(buffer,offset,isBigEndian,noAssert)
function readUInt16(buffer, offset, isBigEndian, noAssert) {
        var val = 0;
        if (!noAssert) {
            assert.ok(typeof isBigEndian === 'boolean', 'missing or invalid endian');
            assert.ok(offset !== undefined && offset !== null, 'missing offset');
            assert.ok(offset + 1 < buffer.length, 'Trying to read beyond buffer length');
        }
        if (offset >= buffer.length)
            return 0;
        if (isBigEndian) {
            val = buffer[offset] << 8;
            if (offset + 1 < buffer.length) {
                val |= buffer[offset + 1];
            }
        } else {
            val = buffer[offset];
            if (offset + 1 < buffer.length) {
                val |= buffer[offset + 1] << 8;
            }
        }
        return val;
    }
    Buffer.prototype.readUInt16LE = function (offset, noAssert) {
        return readUInt16(this, offset, false, noAssert);
    };
    Buffer.prototype.readUInt16BE = function (offset, noAssert) {
        return readUInt16(this, offset, true, noAssert);
    };
    // function readUInt32(buffer,offset,isBigEndian,noAssert)
function readUInt32(buffer, offset, isBigEndian, noAssert) {
        var val = 0;
        if (!noAssert) {
            assert.ok(typeof isBigEndian === 'boolean', 'missing or invalid endian');
            assert.ok(offset !== undefined && offset !== null, 'missing offset');
            assert.ok(offset + 3 < buffer.length, 'Trying to read beyond buffer length');
        }
        if (offset >= buffer.length)
            return 0;
        if (isBigEndian) {
            if (offset + 1 < buffer.length)
                val = buffer[offset + 1] << 16;
            if (offset + 2 < buffer.length)
                val |= buffer[offset + 2] << 8;
            if (offset + 3 < buffer.length)
                val |= buffer[offset + 3];
            val = val + (buffer[offset] << 24 >>> 0);
        } else {
            if (offset + 2 < buffer.length)
                val = buffer[offset + 2] << 16;
            if (offset + 1 < buffer.length)
                val |= buffer[offset + 1] << 8;
            val |= buffer[offset];
            if (offset + 3 < buffer.length)
                val = val + (buffer[offset + 3] << 24 >>> 0);
        }
        return val;
    }
    Buffer.prototype.readUInt32LE = function (offset, noAssert) {
        return readUInt32(this, offset, false, noAssert);
    };
    Buffer.prototype.readUInt32BE = function (offset, noAssert) {
        return readUInt32(this, offset, true, noAssert);
    };
    Buffer.prototype.readInt8 = function (offset, noAssert) {
        var buffer = this;
        var neg;
        if (!noAssert) {
            assert.ok(offset !== undefined && offset !== null, 'missing offset');
            assert.ok(offset < buffer.length, 'Trying to read beyond buffer length');
        }
        if (offset >= buffer.length)
            return;
        neg = buffer[offset] & 128;
        if (!neg) {
            return buffer[offset];
        }
        return (255 - buffer[offset] + 1) * -1;
    };
    // function readInt16(buffer,offset,isBigEndian,noAssert)
function readInt16(buffer, offset, isBigEndian, noAssert) {
        var neg, val;
        if (!noAssert) {
            assert.ok(typeof isBigEndian === 'boolean', 'missing or invalid endian');
            assert.ok(offset !== undefined && offset !== null, 'missing offset');
            assert.ok(offset + 1 < buffer.length, 'Trying to read beyond buffer length');
        }
        val = readUInt16(buffer, offset, isBigEndian, noAssert);
        neg = val & 32768;
        if (!neg) {
            return val;
        }
        return (65535 - val + 1) * -1;
    }
    Buffer.prototype.readInt16LE = function (offset, noAssert) {
        return readInt16(this, offset, false, noAssert);
    };
    Buffer.prototype.readInt16BE = function (offset, noAssert) {
        return readInt16(this, offset, true, noAssert);
    };
    // function readInt32(buffer,offset,isBigEndian,noAssert)
function readInt32(buffer, offset, isBigEndian, noAssert) {
        var neg, val;
        if (!noAssert) {
            assert.ok(typeof isBigEndian === 'boolean', 'missing or invalid endian');
            assert.ok(offset !== undefined && offset !== null, 'missing offset');
            assert.ok(offset + 3 < buffer.length, 'Trying to read beyond buffer length');
        }
        val = readUInt32(buffer, offset, isBigEndian, noAssert);
        neg = val & 2147483648;
        if (!neg) {
            return val;
        }
        return (4294967295 - val + 1) * -1;
    }
    Buffer.prototype.readInt32LE = function (offset, noAssert) {
        return readInt32(this, offset, false, noAssert);
    };
    Buffer.prototype.readInt32BE = function (offset, noAssert) {
        return readInt32(this, offset, true, noAssert);
    };
    // function readFloat(buffer,offset,isBigEndian,noAssert)
function readFloat(buffer, offset, isBigEndian, noAssert) {
        if (!noAssert) {
            assert.ok(typeof isBigEndian === 'boolean', 'missing or invalid endian');
            assert.ok(offset + 3 < buffer.length, 'Trying to read beyond buffer length');
        }
        return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian, 23, 4);
    }
    Buffer.prototype.readFloatLE = function (offset, noAssert) {
        return readFloat(this, offset, false, noAssert);
    };
    Buffer.prototype.readFloatBE = function (offset, noAssert) {
        return readFloat(this, offset, true, noAssert);
    };
    // function readDouble(buffer,offset,isBigEndian,noAssert)
function readDouble(buffer, offset, isBigEndian, noAssert) {
        if (!noAssert) {
            assert.ok(typeof isBigEndian === 'boolean', 'missing or invalid endian');
            assert.ok(offset + 7 < buffer.length, 'Trying to read beyond buffer length');
        }
        return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian, 52, 8);
    }
    Buffer.prototype.readDoubleLE = function (offset, noAssert) {
        return readDouble(this, offset, false, noAssert);
    };
    Buffer.prototype.readDoubleBE = function (offset, noAssert) {
        return readDouble(this, offset, true, noAssert);
    };
    // function verifuint(value,max)
function verifuint(value, max) {
        assert.ok(typeof value == 'number', 'cannot write a non-number as a number');
        assert.ok(value >= 0, 'specified a negative value for writing an unsigned value');
        assert.ok(value <= max, 'value is larger than maximum value for type');
        assert.ok(Math.floor(value) === value, 'value has a fractional component');
    }
    Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
        var buffer = this;
        if (!noAssert) {
            assert.ok(value !== undefined && value !== null, 'missing value');
            assert.ok(offset !== undefined && offset !== null, 'missing offset');
            assert.ok(offset < buffer.length, 'trying to write beyond buffer length');
            verifuint(value, 255);
        }
        if (offset < buffer.length) {
            buffer[offset] = value;
        }
    };
    // function writeUInt16(buffer,value,offset,isBigEndian,noAssert)
function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
        if (!noAssert) {
            assert.ok(value !== undefined && value !== null, 'missing value');
            assert.ok(typeof isBigEndian === 'boolean', 'missing or invalid endian');
            assert.ok(offset !== undefined && offset !== null, 'missing offset');
            assert.ok(offset + 1 < buffer.length, 'trying to write beyond buffer length');
            verifuint(value, 65535);
        }
        for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
            buffer[offset + i] = (value & 255 << 8 * (isBigEndian ? 1 - i : i)) >>> (isBigEndian ? 1 - i : i) * 8;
        }
    }
    Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
        writeUInt16(this, value, offset, false, noAssert);
    };
    Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
        writeUInt16(this, value, offset, true, noAssert);
    };
    // function writeUInt32(buffer,value,offset,isBigEndian,noAssert)
function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
        if (!noAssert) {
            assert.ok(value !== undefined && value !== null, 'missing value');
            assert.ok(typeof isBigEndian === 'boolean', 'missing or invalid endian');
            assert.ok(offset !== undefined && offset !== null, 'missing offset');
            assert.ok(offset + 3 < buffer.length, 'trying to write beyond buffer length');
            verifuint(value, 4294967295);
        }
        for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
            buffer[offset + i] = value >>> (isBigEndian ? 3 - i : i) * 8 & 255;
        }
    }
    Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
        writeUInt32(this, value, offset, false, noAssert);
    };
    Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
        writeUInt32(this, value, offset, true, noAssert);
    };
    // function verifsint(value,max,min)
function verifsint(value, max, min) {
        assert.ok(typeof value == 'number', 'cannot write a non-number as a number');
        assert.ok(value <= max, 'value larger than maximum allowed value');
        assert.ok(value >= min, 'value smaller than minimum allowed value');
        assert.ok(Math.floor(value) === value, 'value has a fractional component');
    }
    // function verifIEEE754(value,max,min)
function verifIEEE754(value, max, min) {
        assert.ok(typeof value == 'number', 'cannot write a non-number as a number');
        assert.ok(value <= max, 'value larger than maximum allowed value');
        assert.ok(value >= min, 'value smaller than minimum allowed value');
    }
    Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
        var buffer = this;
        if (!noAssert) {
            assert.ok(value !== undefined && value !== null, 'missing value');
            assert.ok(offset !== undefined && offset !== null, 'missing offset');
            assert.ok(offset < buffer.length, 'Trying to write beyond buffer length');
            verifsint(value, 127, -128);
        }
        if (value >= 0) {
            buffer.writeUInt8(value, offset, noAssert);
        } else {
            buffer.writeUInt8(255 + value + 1, offset, noAssert);
        }
    };
    // function writeInt16(buffer,value,offset,isBigEndian,noAssert)
function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
        if (!noAssert) {
            assert.ok(value !== undefined && value !== null, 'missing value');
            assert.ok(typeof isBigEndian === 'boolean', 'missing or invalid endian');
            assert.ok(offset !== undefined && offset !== null, 'missing offset');
            assert.ok(offset + 1 < buffer.length, 'Trying to write beyond buffer length');
            verifsint(value, 32767, -32768);
        }
        if (value >= 0) {
            writeUInt16(buffer, value, offset, isBigEndian, noAssert);
        } else {
            writeUInt16(buffer, 65535 + value + 1, offset, isBigEndian, noAssert);
        }
    }
    Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
        writeInt16(this, value, offset, false, noAssert);
    };
    Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
        writeInt16(this, value, offset, true, noAssert);
    };
    // function writeInt32(buffer,value,offset,isBigEndian,noAssert)
function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
        if (!noAssert) {
            assert.ok(value !== undefined && value !== null, 'missing value');
            assert.ok(typeof isBigEndian === 'boolean', 'missing or invalid endian');
            assert.ok(offset !== undefined && offset !== null, 'missing offset');
            assert.ok(offset + 3 < buffer.length, 'Trying to write beyond buffer length');
            verifsint(value, 2147483647, -2147483648);
        }
        if (value >= 0) {
            writeUInt32(buffer, value, offset, isBigEndian, noAssert);
        } else {
            writeUInt32(buffer, 4294967295 + value + 1, offset, isBigEndian, noAssert);
        }
    }
    Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
        writeInt32(this, value, offset, false, noAssert);
    };
    Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
        writeInt32(this, value, offset, true, noAssert);
    };
    // function writeFloat(buffer,value,offset,isBigEndian,noAssert)
function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
        if (!noAssert) {
            assert.ok(value !== undefined && value !== null, 'missing value');
            assert.ok(typeof isBigEndian === 'boolean', 'missing or invalid endian');
            assert.ok(offset !== undefined && offset !== null, 'missing offset');
            assert.ok(offset + 3 < buffer.length, 'Trying to write beyond buffer length');
            verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
        }
        require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian, 23, 4);
    }
    Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
        writeFloat(this, value, offset, false, noAssert);
    };
    Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
        writeFloat(this, value, offset, true, noAssert);
    };
    // function writeDouble(buffer,value,offset,isBigEndian,noAssert)
function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
        if (!noAssert) {
            assert.ok(value !== undefined && value !== null, 'missing value');
            assert.ok(typeof isBigEndian === 'boolean', 'missing or invalid endian');
            assert.ok(offset !== undefined && offset !== null, 'missing offset');
            assert.ok(offset + 7 < buffer.length, 'Trying to write beyond buffer length');
            verifIEEE754(value, 1.7976931348623157e+308, -1.7976931348623157e+308);
        }
        require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian, 52, 8);
    }
    Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
        writeDouble(this, value, offset, false, noAssert);
    };
    Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
        writeDouble(this, value, offset, true, noAssert);
    };
};
BundleObjectCode['os/base64'] = function (module, exports) {
    var keyStr = 'ABCDEFGHIJKLMNOP' + 'QRSTUVWXYZabcdef' + 'ghijklmnopqrstuv' + 'wxyz0123456789+/' + '=';
    var Buffer = Require('buffer').Buffer;
    var Base64 = {
        encode: function (input) {
            input = escape(input);
            var output = '';
            var chr1, chr2, chr3 = '';
            var enc1, enc2, enc3, enc4 = '';
            var i = 0;
            do {
                chr1 = input.charCodeAt(i++);
                chr2 = input.charCodeAt(i++);
                chr3 = input.charCodeAt(i++);
                enc1 = chr1 >> 2;
                enc2 = (chr1 & 3) << 4 | chr2 >> 4;
                enc3 = (chr2 & 15) << 2 | chr3 >> 6;
                enc4 = chr3 & 63;
                if (isNaN(chr2)) {
                    enc3 = enc4 = 64;
                } else if (isNaN(chr3)) {
                    enc4 = 64;
                }
                output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);
                chr1 = chr2 = chr3 = '';
                enc1 = enc2 = enc3 = enc4 = '';
            } while (i < input.length);
            return output;
        },
        encodeBuf: function (input) {
            var output = '';
            var NaN = output.charCodeAt(2);
            var chr1, chr2, chr3 = '';
            var enc1, enc2, enc3, enc4 = '';
            var i = 0;
            var len = input.length;
            do {
                chr1 = input.readUInt8(i++);
                chr2 = i < len ? input.readUInt8(i++) : NaN;
                chr3 = i < len ? input.readUInt8(i++) : NaN;
                enc1 = chr1 >> 2;
                enc2 = (chr1 & 3) << 4 | chr2 >> 4;
                enc3 = (chr2 & 15) << 2 | chr3 >> 6;
                enc4 = chr3 & 63;
                if (isNaN(chr2)) {
                    enc3 = enc4 = 64;
                } else if (isNaN(chr3)) {
                    enc4 = 64;
                }
                output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);
                chr1 = chr2 = chr3 = '';
                enc1 = enc2 = enc3 = enc4 = '';
            } while (i < len);
            return output;
        },
        decode: function (input) {
            var output = '';
            var chr1, chr2, chr3 = '';
            var enc1, enc2, enc3, enc4 = '';
            var i = 0;
            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
            do {
                enc1 = keyStr.indexOf(input.charAt(i++));
                enc2 = keyStr.indexOf(input.charAt(i++));
                enc3 = keyStr.indexOf(input.charAt(i++));
                enc4 = keyStr.indexOf(input.charAt(i++));
                chr1 = enc1 << 2 | enc2 >> 4;
                chr2 = (enc2 & 15) << 4 | enc3 >> 2;
                chr3 = (enc3 & 3) << 6 | enc4;
                output = output + String.fromCharCode(chr1);
                if (enc3 != 64) {
                    output = output + String.fromCharCode(chr2);
                }
                if (enc4 != 64) {
                    output = output + String.fromCharCode(chr3);
                }
                chr1 = chr2 = chr3 = '';
                enc1 = enc2 = enc3 = enc4 = '';
            } while (i < input.length);
            return unescape(output);
        },
        decodeBuf: function (input) {
            var len = input.length;
            var buf = new Buffer(len);
            var chr1, chr2, chr3 = '';
            var enc1, enc2, enc3, enc4 = '';
            var i = 0;
            var buflen = 0;
            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
            buf.fill(0);
            do {
                enc1 = keyStr.indexOf(input.charAt(i++));
                enc2 = keyStr.indexOf(input.charAt(i++));
                enc3 = keyStr.indexOf(input.charAt(i++));
                enc4 = keyStr.indexOf(input.charAt(i++));
                chr1 = enc1 << 2 | enc2 >> 4;
                chr2 = (enc2 & 15) << 4 | enc3 >> 2;
                chr3 = (enc3 & 3) << 6 | enc4;
                buf.writeUInt8(chr1, buflen);
                buflen++;
                if (enc3 != 64) {
                    buf.writeUInt8(chr2, buflen);
                    buflen++;
                }
                if (enc4 != 64) {
                    buf.writeUInt8(chr3, buflen);
                    buflen++;
                }
                chr1 = chr2 = chr3 = '';
                enc1 = enc2 = enc3 = enc4 = '';
            } while (i < input.length);
            return buf.slice(0, buflen);
        }
    };
    module.exports = Base64;
};
BundleObjectCode['os/crypto.rand'] = function (module, exports) {
    var crypto = global.crypto || global.msCrypto;
    if (!crypto && typeof require != 'undefined')
        try {
            crypto = global.crypto = require('require');
        } catch (e) {
        }
    
    var twister;
    var MersenneTwister = function (seed) {
        if (seed == undefined) {
            seed = new Date().getTime();
            seed *= Math.random() * 91713;
            seed |= 0;
        }
        this.N = 624;
        this.M = 397;
        this.MATRIX_A = 2567483615;
        this.UPPER_MASK = 2147483648;
        this.LOWER_MASK = 2147483647;
        this.mt = new Array(this.N);
        this.mti = this.N + 1;
        if (seed.constructor == Array) {
            this.init_by_array(seed, seed.length);
        } else {
            this.init_seed(seed);
        }
    };
    MersenneTwister.prototype.init_seed = function (s) {
        this.mt[0] = s >>> 0;
        for (this.mti = 1; this.mti < this.N; this.mti++) {
            var s = this.mt[this.mti - 1] ^ this.mt[this.mti - 1] >>> 30;
            this.mt[this.mti] = (((s & 4294901760) >>> 16) * 1812433253 << 16) + (s & 65535) * 1812433253 + this.mti;
            this.mt[this.mti] >>>= 0;
        }
    };
    MersenneTwister.prototype.init_by_array = function (init_key, key_length) {
        var i, j, k;
        this.init_seed(19650218);
        i = 1;
        j = 0;
        k = this.N > key_length ? this.N : key_length;
        for (; k; k--) {
            var s = this.mt[i - 1] ^ this.mt[i - 1] >>> 30;
            this.mt[i] = (this.mt[i] ^ (((s & 4294901760) >>> 16) * 1664525 << 16) + (s & 65535) * 1664525) + init_key[j] + j;
            this.mt[i] >>>= 0;
            i++;
            j++;
            if (i >= this.N) {
                this.mt[0] = this.mt[this.N - 1];
                i = 1;
            }
            if (j >= key_length)
                j = 0;
        }
        for (k = this.N - 1; k; k--) {
            var s = this.mt[i - 1] ^ this.mt[i - 1] >>> 30;
            this.mt[i] = (this.mt[i] ^ (((s & 4294901760) >>> 16) * 1566083941 << 16) + (s & 65535) * 1566083941) - i;
            this.mt[i] >>>= 0;
            i++;
            if (i >= this.N) {
                this.mt[0] = this.mt[this.N - 1];
                i = 1;
            }
        }
        this.mt[0] = 2147483648;
    };
    MersenneTwister.prototype.random_int = function () {
        var y;
        var mag01 = new Array(0, this.MATRIX_A);
        if (this.mti >= this.N) {
            var kk;
            if (this.mti == this.N + 1)
                this.init_seed(5489);
            for (kk = 0; kk < this.N - this.M; kk++) {
                y = this.mt[kk] & this.UPPER_MASK | this.mt[kk + 1] & this.LOWER_MASK;
                this.mt[kk] = this.mt[kk + this.M] ^ y >>> 1 ^ mag01[y & 1];
            }
            for (; kk < this.N - 1; kk++) {
                y = this.mt[kk] & this.UPPER_MASK | this.mt[kk + 1] & this.LOWER_MASK;
                this.mt[kk] = this.mt[kk + (this.M - this.N)] ^ y >>> 1 ^ mag01[y & 1];
            }
            y = this.mt[this.N - 1] & this.UPPER_MASK | this.mt[0] & this.LOWER_MASK;
            this.mt[this.N - 1] = this.mt[this.M - 1] ^ y >>> 1 ^ mag01[y & 1];
            this.mti = 0;
        }
        y = this.mt[this.mti++];
        y ^= y >>> 11;
        y ^= y << 7 & 2636928640;
        y ^= y << 15 & 4022730752;
        y ^= y >>> 18;
        return y >>> 0;
    };
    MersenneTwister.prototype.random_int31 = function () {
        return this.random_int() >>> 1;
    };
    MersenneTwister.prototype.random_incl = function () {
        return this.random_int() * (1 / 4294967295);
    };
    MersenneTwister.prototype.random = function () {
        return this.random_int() * (1 / 4294967296);
    };
    MersenneTwister.prototype.random_excl = function () {
        return (this.random_int() + 0.5) * (1 / 4294967296);
    };
    MersenneTwister.prototype.random_long = function () {
        var a = this.random_int() >>> 5, b = this.random_int() >>> 6;
        return (a * 67108864 + b) * (1 / 9007199254740992);
    };
    // function polyfill()
function polyfill() {
        twister = new MersenneTwister();
        if (!crypto)
            crypto = global.crypto = {};
        crypto.getRandomValues = function getRandomValues(abv) {
            var l = abv.length;
            while (l--) {
                abv[l] = Math.floor(twister.random() * 256);
            }
            return abv;
        };
        if (!global.Uint8Array && !Uint8Array)
            throw new Error('crypto.rand: No Uint8Array found!');
        if (!global.Uint8Array)
            global.Uint8Array = Uint8Array;
    }
    // function randomByte(min,max)
function randomByte(min, max) {
        if (!twister)
            twister = new MersenneTwister();
        return Math.floor(twister.random() * (max - min)) + min;
    }
    // function randomBytes(size,cb)
function randomBytes(size, cb) {
        if (size > 65536)
            throw new Error('requested too many random bytes');
        if (!crypto || !crypto.getRandomValues)
            polyfill();
        var rawBytes = new global.Uint8Array(size);
        if (size > 0) {
            crypto.getRandomValues(rawBytes);
        }
        var bytes = new Buffer(rawBytes);
        if (typeof cb === 'function') {
            cb(null, bytes);
        }
        return bytes;
    }
    module.exports = {
        randomByte: randomByte,
        randomBytes: randomBytes
    };
};
BundleObjectCode['os/events'] = function (module, exports) {
    // function EventEmitter()
function EventEmitter() {
        this._events = this._events || {};
        this._maxListeners = this._maxListeners || undefined;
    }
    module.exports = EventEmitter;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = undefined;
    EventEmitter.prototype._maxListeners = undefined;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.prototype.setMaxListeners = function (n) {
        if (!isNumber(n) || n < 0 || isNaN(n))
            throw TypeError('n must be a positive number');
        this._maxListeners = n;
        return this;
    };
    EventEmitter.prototype.emit = function (type) {
        var er, handler, len, args, i, listeners;
        if (!this._events)
            this._events = {};
        if (type === 'error') {
            if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
                er = arguments[1];
                if (er instanceof Error) {
                    throw er;
                } else {
                    var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
                    err.context = er;
                    throw err;
                }
            }
        }
        handler = this._events[type];
        if (isUndefined(handler))
            return false;
        if (isFunction(handler)) {
            switch (arguments.length) {
            case 1:
                handler.call(this);
                break;
            case 2:
                handler.call(this, arguments[1]);
                break;
            case 3:
                handler.call(this, arguments[1], arguments[2]);
                break;
            default:
                args = Array.prototype.slice.call(arguments, 1);
                handler.apply(this, args);
            }
        } else if (isObject(handler)) {
            args = Array.prototype.slice.call(arguments, 1);
            listeners = handler.slice();
            len = listeners.length;
            for (i = 0; i < len; i++)
                listeners[i].apply(this, args);
        }
        return true;
    };
    EventEmitter.prototype.addListener = function (type, listener) {
        var m;
        if (!isFunction(listener))
            throw TypeError('listener must be a function');
        if (!this._events)
            this._events = {};
        if (this._events.newListener)
            this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);
        if (!this._events[type])
            this._events[type] = listener;
        else if (isObject(this._events[type]))
            this._events[type].push(listener);
        else
            this._events[type] = [
                this._events[type],
                listener
            ];
        if (isObject(this._events[type]) && !this._events[type].warned) {
            if (!isUndefined(this._maxListeners)) {
                m = this._maxListeners;
            } else {
                m = EventEmitter.defaultMaxListeners;
            }
            if (m && m > 0 && this._events[type].length > m) {
                this._events[type].warned = true;
                console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
                if (typeof console.trace === 'function') {
                    console.trace();
                }
            }
        }
        return this;
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.once = function (type, listener) {
        if (!isFunction(listener))
            throw TypeError('listener must be a function');
        var fired = false;
        // function g()
function g() {
            this.removeListener(type, g);
            if (!fired) {
                fired = true;
                listener.apply(this, arguments);
            }
        }
        g.listener = listener;
        this.on(type, g);
        return this;
    };
    EventEmitter.prototype.removeListener = function (type, listener) {
        var list, position, length, i;
        if (!isFunction(listener))
            throw TypeError('listener must be a function');
        if (!this._events || !this._events[type])
            return this;
        list = this._events[type];
        length = list.length;
        position = -1;
        if (list === listener || isFunction(list.listener) && list.listener === listener) {
            delete this._events[type];
            if (this._events.removeListener)
                this.emit('removeListener', type, listener);
        } else if (isObject(list)) {
            for (i = length; i-- > 0;) {
                if (list[i] === listener || list[i].listener && list[i].listener === listener) {
                    position = i;
                    break;
                }
            }
            if (position < 0)
                return this;
            if (list.length === 1) {
                list.length = 0;
                delete this._events[type];
            } else {
                list.splice(position, 1);
            }
            if (this._events.removeListener)
                this.emit('removeListener', type, listener);
        }
        return this;
    };
    EventEmitter.prototype.removeAllListeners = function (type) {
        var key, listeners;
        if (!this._events)
            return this;
        if (!this._events.removeListener) {
            if (arguments.length === 0)
                this._events = {};
            else if (this._events[type])
                delete this._events[type];
            return this;
        }
        if (arguments.length === 0) {
            for (key in this._events) {
                if (key === 'removeListener')
                    continue;
                this.removeAllListeners(key);
            }
            this.removeAllListeners('removeListener');
            this._events = {};
            return this;
        }
        listeners = this._events[type];
        if (isFunction(listeners)) {
            this.removeListener(type, listeners);
        } else if (listeners) {
            while (listeners.length)
                this.removeListener(type, listeners[listeners.length - 1]);
        }
        delete this._events[type];
        return this;
    };
    EventEmitter.prototype.listeners = function (type) {
        var ret;
        if (!this._events || !this._events[type])
            ret = [];
        else if (isFunction(this._events[type]))
            ret = [this._events[type]];
        else
            ret = this._events[type].slice();
        return ret;
    };
    EventEmitter.prototype.listenerCount = function (type) {
        if (this._events) {
            var evlistener = this._events[type];
            if (isFunction(evlistener))
                return 1;
            else if (evlistener)
                return evlistener.length;
        }
        return 0;
    };
    EventEmitter._listenerCount = function (ee, event) {
        var listeners = ee && ee._events && ee._events[event];
        if (Array.isArray(listeners)) {
            return listeners.length;
        } else if (typeof listeners === 'function') {
            return 1;
        } else {
            return 0;
        }
    };
    EventEmitter.listenerCount = function (emitter, type) {
        if (emitter.listenerCount == undefined)
            return EventEmitter._listenerCount(emitter, type);
        else
            return emitter.listenerCount(type);
    };
    // function isFunction(arg)
function isFunction(arg) {
        return typeof arg === 'function';
    }
    // function isNumber(arg)
function isNumber(arg) {
        return typeof arg === 'number';
    }
    // function isObject(arg)
function isObject(arg) {
        return typeof arg === 'object' && arg !== null;
    }
    // function isUndefined(arg)
function isUndefined(arg) {
        return arg === void 0;
    }
};
BundleObjectCode['os/path'] = function (module, exports) {
    var Fs = Require('fs');
    var _process = process || {};
    (function () {
        'use strict';
        var isWindows = _process.platform === 'win32';
        var util = Require('util');
        if (!util.deprecate)
            util.deprecate = function (f, w) {
                return f;
            };
        // function normalizeArray(parts,allowAboveRoot)
function normalizeArray(parts, allowAboveRoot) {
            var up = 0;
            for (var i = parts.length - 1; i >= 0; i--) {
                var last = parts[i];
                if (last === '.') {
                    parts.splice(i, 1);
                } else if (last === '..') {
                    parts.splice(i, 1);
                    up++;
                } else if (up) {
                    parts.splice(i, 1);
                    up--;
                }
            }
            if (allowAboveRoot) {
                for (; up--; up) {
                    parts.unshift('..');
                }
            }
            return parts;
        }
        if (isWindows) {
            var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
            var splitTailRe = /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;
            var splitPath = function (filename) {
                var result = splitDeviceRe.exec(filename), device = (result[1] || '') + (result[2] || ''), tail = result[3] || '';
                var result2 = splitTailRe.exec(tail), dir = result2[1], basename = result2[2], ext = result2[3];
                return [
                    device,
                    dir,
                    basename,
                    ext
                ];
            };
            var normalizeUNCRoot = function (device) {
                return '\\\\' + device.replace(/^[\\\/]+/, '').replace(/[\\\/]+/g, '\\');
            };
            exports.resolve = function () {
                var resolvedDevice = '', resolvedTail = '', resolvedAbsolute = false;
                for (var i = arguments.length - 1; i >= -1; i--) {
                    var path;
                    if (i >= 0) {
                        path = arguments[i];
                    } else if (!resolvedDevice) {
                        path = _process.cwd();
                    } else {
                        path = _process.env['=' + resolvedDevice];
                        if (!path || path.substr(0, 3).toLowerCase() !== resolvedDevice.toLowerCase() + '\\') {
                            path = resolvedDevice + '\\';
                        }
                    }
                    if (!util.isString(path)) {
                        throw new TypeError('Arguments to path.resolve must be strings');
                    } else if (!path) {
                        continue;
                    }
                    var result = splitDeviceRe.exec(path), device = result[1] || '', isUnc = device && device.charAt(1) !== ':', isAbsolute = exports.isAbsolute(path), tail = result[3];
                    if (device && resolvedDevice && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
                        continue;
                    }
                    if (!resolvedDevice) {
                        resolvedDevice = device;
                    }
                    if (!resolvedAbsolute) {
                        resolvedTail = tail + '\\' + resolvedTail;
                        resolvedAbsolute = isAbsolute;
                    }
                    if (resolvedDevice && resolvedAbsolute) {
                        break;
                    }
                }
                if (isUnc) {
                    resolvedDevice = normalizeUNCRoot(resolvedDevice);
                }
                // function f(p)
function f(p) {
                    return !!p;
                }
                resolvedTail = normalizeArray(resolvedTail.split(/[\\\/]+/).filter(f), !resolvedAbsolute).join('\\');
                return resolvedDevice + (resolvedAbsolute ? '\\' : '') + resolvedTail || '.';
            };
            exports.normalize = function (path) {
                var result = splitDeviceRe.exec(path), device = result[1] || '', isUnc = device && device.charAt(1) !== ':', isAbsolute = exports.isAbsolute(path), tail = result[3], trailingSlash = /[\\\/]$/.test(tail);
                if (device && device.charAt(1) === ':') {
                    device = device[0].toLowerCase() + device.substr(1);
                }
                tail = normalizeArray(tail.split(/[\\\/]+/).filter(function (p) {
                    return !!p;
                }), !isAbsolute).join('\\');
                if (!tail && !isAbsolute) {
                    tail = '.';
                }
                if (tail && trailingSlash) {
                    tail += '\\';
                }
                if (isUnc) {
                    device = normalizeUNCRoot(device);
                }
                return device + (isAbsolute ? '\\' : '') + tail;
            };
            exports.isAbsolute = function (path) {
                var result = splitDeviceRe.exec(path), device = result[1] || '', isUnc = !!device && device.charAt(1) !== ':';
                return !!result[2] || isUnc;
            };
            exports.join = function () {
                // function f(p)
function f(p) {
                    if (!util.isString(p)) {
                        throw new TypeError('Arguments to path.join must be strings');
                    }
                    return p;
                }
                var paths = Array.prototype.filter.call(arguments, f);
                var joined = paths.join('\\');
                if (!/^[\\\/]{2}[^\\\/]/.test(paths[0])) {
                    joined = joined.replace(/^[\\\/]{2,}/, '\\');
                }
                return exports.normalize(joined);
            };
            exports.relative = function (from, to) {
                from = exports.resolve(from);
                to = exports.resolve(to);
                var lowerFrom = from.toLowerCase();
                var lowerTo = to.toLowerCase();
                // function trim(arr)
function trim(arr) {
                    var start = 0;
                    for (; start < arr.length; start++) {
                        if (arr[start] !== '')
                            break;
                    }
                    var end = arr.length - 1;
                    for (; end >= 0; end--) {
                        if (arr[end] !== '')
                            break;
                    }
                    if (start > end)
                        return [];
                    return arr.slice(start, end + 1);
                }
                var toParts = trim(to.split('\\'));
                var lowerFromParts = trim(lowerFrom.split('\\'));
                var lowerToParts = trim(lowerTo.split('\\'));
                var length = Math.min(lowerFromParts.length, lowerToParts.length);
                var samePartsLength = length;
                for (var i = 0; i < length; i++) {
                    if (lowerFromParts[i] !== lowerToParts[i]) {
                        samePartsLength = i;
                        break;
                    }
                }
                if (samePartsLength == 0) {
                    return to;
                }
                var outputParts = [];
                for (var i = samePartsLength; i < lowerFromParts.length; i++) {
                    outputParts.push('..');
                }
                outputParts = outputParts.concat(toParts.slice(samePartsLength));
                return outputParts.join('\\');
            };
            exports.sep = '\\';
            exports.delimiter = ';';
        } else {
            var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
            var splitPath = function (filename) {
                return splitPathRe.exec(filename).slice(1);
            };
            exports.resolve = function () {
                var resolvedPath = '', resolvedAbsolute = false;
                for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
                    var path = i >= 0 ? arguments[i] : _process.cwd();
                    if (!util.isString(path)) {
                        throw new TypeError('Arguments to path.resolve must be strings');
                    } else if (!path) {
                        continue;
                    }
                    resolvedPath = path + '/' + resolvedPath;
                    resolvedAbsolute = path.charAt(0) === '/';
                }
                resolvedPath = normalizeArray(resolvedPath.split('/').filter(function (p) {
                    return !!p;
                }), !resolvedAbsolute).join('/');
                return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
            };
            exports.normalize = function (path) {
                var isAbsolute = exports.isAbsolute(path), trailingSlash = path[path.length - 1] === '/', segments = path.split('/'), nonEmptySegments = [];
                for (var i = 0; i < segments.length; i++) {
                    if (segments[i]) {
                        nonEmptySegments.push(segments[i]);
                    }
                }
                path = normalizeArray(nonEmptySegments, !isAbsolute).join('/');
                if (!path && !isAbsolute) {
                    path = '.';
                }
                if (path && trailingSlash) {
                    path += '/';
                }
                return (isAbsolute ? '/' : '') + path;
            };
            exports.isAbsolute = function (path) {
                return path.charAt(0) === '/';
            };
            exports.join = function () {
                var path = '';
                for (var i = 0; i < arguments.length; i++) {
                    var segment = arguments[i];
                    if (!util.isString(segment)) {
                        throw new TypeError('Arguments to path.join must be strings');
                    }
                    if (segment) {
                        if (!path) {
                            path += segment;
                        } else {
                            path += '/' + segment;
                        }
                    }
                }
                return exports.normalize(path);
            };
            exports.relative = function (from, to) {
                from = exports.resolve(from).substr(1);
                to = exports.resolve(to).substr(1);
                // function trim(arr)
function trim(arr) {
                    var start = 0;
                    for (; start < arr.length; start++) {
                        if (arr[start] !== '')
                            break;
                    }
                    var end = arr.length - 1;
                    for (; end >= 0; end--) {
                        if (arr[end] !== '')
                            break;
                    }
                    if (start > end)
                        return [];
                    return arr.slice(start, end + 1);
                }
                var fromParts = trim(from.split('/'));
                var toParts = trim(to.split('/'));
                var length = Math.min(fromParts.length, toParts.length);
                var samePartsLength = length;
                for (var i = 0; i < length; i++) {
                    if (fromParts[i] !== toParts[i]) {
                        samePartsLength = i;
                        break;
                    }
                }
                var outputParts = [];
                for (var i = samePartsLength; i < fromParts.length; i++) {
                    outputParts.push('..');
                }
                outputParts = outputParts.concat(toParts.slice(samePartsLength));
                return outputParts.join('/');
            };
            exports.sep = '/';
            exports.delimiter = ':';
        }
        exports.dirname = function (path) {
            var result = splitPath(path), root = result[0], dir = result[1];
            if (!root && !dir) {
                return '.';
            }
            if (dir) {
                dir = dir.substr(0, dir.length - 1);
            }
            return root + dir;
        };
        exports.basename = function (path, ext) {
            var f = splitPath(path)[2];
            if (ext && f.substr(-1 * ext.length) === ext) {
                f = f.substr(0, f.length - ext.length);
            }
            return f;
        };
        exports.extname = function (path) {
            return splitPath(path)[3];
        };
        exports.exists = util.deprecate(function (path, callback) {
            if (Fs)
                Fs.exists(path, callback);
            else
                callback(false);
        }, 'path.exists is now called `fs.exists`.');
        exports.existsSync = util.deprecate(function (path) {
            if (Fs)
                return Fs.existsSync(path);
            else
                return false;
        }, 'path.existsSync is now called `fs.existsSync`.');
        if (isWindows) {
            exports._makeLong = function (path) {
                if (!util.isString(path))
                    return path;
                if (!path) {
                    return '';
                }
                var resolvedPath = exports.resolve(path);
                if (/^[a-zA-Z]\:\\/.test(resolvedPath)) {
                    return '\\\\?\\' + resolvedPath;
                } else if (/^\\\\[^?.]/.test(resolvedPath)) {
                    return '\\\\?\\UNC\\' + resolvedPath.substring(2);
                }
                return path;
            };
        } else {
            exports._makeLong = function (path) {
                return path;
            };
        }
    }());
};
BundleObjectCode['os/string_decoder'] = function (module, exports) {
    var Buffer = require('buffer').Buffer;
    var isBufferEncoding = Buffer.isEncoding || function (encoding) {
        switch (encoding && encoding.toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
        case 'raw':
            return true;
        default:
            return false;
        }
    };
    // function assertEncoding(encoding)
function assertEncoding(encoding) {
        if (encoding && !isBufferEncoding(encoding)) {
            throw new Error('Unknown encoding: ' + encoding);
        }
    }
    var StringDecoder = exports.StringDecoder = function (encoding) {
        this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
        assertEncoding(encoding);
        switch (this.encoding) {
        case 'utf8':
            this.surrogateSize = 3;
            break;
        case 'ucs2':
        case 'utf16le':
            this.surrogateSize = 2;
            this.detectIncompleteChar = utf16DetectIncompleteChar;
            break;
        case 'base64':
            this.surrogateSize = 3;
            this.detectIncompleteChar = base64DetectIncompleteChar;
            break;
        default:
            this.write = passThroughWrite;
            return;
        }
        this.charBuffer = new Buffer(6);
        this.charReceived = 0;
        this.charLength = 0;
    };
    StringDecoder.prototype.write = function (buffer) {
        var charStr = '';
        var offset = 0;
        while (this.charLength) {
            var i = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
            buffer.copy(this.charBuffer, this.charReceived, offset, i);
            this.charReceived += i - offset;
            offset = i;
            if (this.charReceived < this.charLength) {
                return '';
            }
            charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
            var charCode = charStr.charCodeAt(charStr.length - 1);
            if (charCode >= 55296 && charCode <= 56319) {
                this.charLength += this.surrogateSize;
                charStr = '';
                continue;
            }
            this.charReceived = this.charLength = 0;
            if (i == buffer.length)
                return charStr;
            buffer = buffer.slice(i, buffer.length);
            break;
        }
        var lenIncomplete = this.detectIncompleteChar(buffer);
        var end = buffer.length;
        if (this.charLength) {
            buffer.copy(this.charBuffer, 0, buffer.length - lenIncomplete, end);
            this.charReceived = lenIncomplete;
            end -= lenIncomplete;
        }
        charStr += buffer.toString(this.encoding, 0, end);
        var end = charStr.length - 1;
        var charCode = charStr.charCodeAt(end);
        if (charCode >= 55296 && charCode <= 56319) {
            var size = this.surrogateSize;
            this.charLength += size;
            this.charReceived += size;
            this.charBuffer.copy(this.charBuffer, size, 0, size);
            this.charBuffer.write(charStr.charAt(charStr.length - 1), this.encoding);
            return charStr.substring(0, end);
        }
        return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function (buffer) {
        var i = buffer.length >= 3 ? 3 : buffer.length;
        for (; i > 0; i--) {
            var c = buffer[buffer.length - i];
            if (i == 1 && c >> 5 == 6) {
                this.charLength = 2;
                break;
            }
            if (i <= 2 && c >> 4 == 14) {
                this.charLength = 3;
                break;
            }
            if (i <= 3 && c >> 3 == 30) {
                this.charLength = 4;
                break;
            }
        }
        return i;
    };
    StringDecoder.prototype.end = function (buffer) {
        var res = '';
        if (buffer && buffer.length)
            res = this.write(buffer);
        if (this.charReceived) {
            var cr = this.charReceived;
            var buf = this.charBuffer;
            var enc = this.encoding;
            res += buf.slice(0, cr).toString(enc);
        }
        return res;
    };
    // function passThroughWrite(buffer)
function passThroughWrite(buffer) {
        return buffer.toString(this.encoding);
    }
    // function utf16DetectIncompleteChar(buffer)
function utf16DetectIncompleteChar(buffer) {
        var incomplete = this.charReceived = buffer.length % 2;
        this.charLength = incomplete ? 2 : 0;
        return incomplete;
    }
    // function base64DetectIncompleteChar(buffer)
function base64DetectIncompleteChar(buffer) {
        var incomplete = this.charReceived = buffer.length % 3;
        this.charLength = incomplete ? 3 : 0;
        return incomplete;
    }
};
BundleObjectCode['_dummy'] = function (module, exports) {
    var x, y, z;
    // function f1(c:complex) -> number;
};
var Base64 = Require('os/base64');
Require('main');